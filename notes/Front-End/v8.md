# v8引擎

在chrome浏览器内JavaScript是在v8上解释执行的，NodeJs就是基于JavaScript环境和语言编写的，它的执行环境也就离不开v8了。

![Chrome浏览器和Node的组件构成对比](https://raw.githubusercontent.com/Qbian61/Qbian61.github.io/master/resource/nodejs-v8-gc/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8CNode%E7%9A%84%E7%BB%84%E4%BB%B6%E6%9E%84%E6%88%90.png)

## 内存限制

在JavaScript中，内存的使用受到了V8虚拟机的限制。

因为V8是为Chrome浏览器研发产生的，在浏览器环境内并不会存在使用大量内存的情况，所以V8在内存使用上对不同平台做了相对应的限制：32位操作系统约为0.7GB，64位操作系统约为1.4GB。

着当我们在操作大文件时（超过该内存限制的文件），无法将文件全部读取到内存中来，相对应的计算机的内存资源也就无法得到充分的使用。

## 内存

### 堆内存

V8和java中的对象分配是一样的，都在堆内存中，当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的堆空闲内存不够分配新对象时，将继续申请堆内存，直到堆的大小超过V8的限制为止。

查看 node 内存使用情况

```js
process.memoryUseage();
```

## 垃圾回收机制

V8的垃圾回收策略主要基于分代垃圾回收机制。

V8将整个堆内存分为*新生代内存*和*老龄代内存*，*新生代内存*使用的是复制算法，保存的是最新创建且存活周期短的对象。*老龄代内存*使用的是标记－清除算法以及标记－合并算法，保存的是较为活跃且存活周期长的对象。

### 复制算法

该算法又将*新生代内存*一分为二，在这两个空间中，只有一个处于使用中，另一个处于闲置状态。正在使用的空间我们称之为From空间，处于闲置的空间我们称之为To空间。

当我们分配对象时，先是在From空间进行分配。当*新生代内存*中开始垃圾回收时，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而非存活对象占用的空间将被释放。
完成复制后，From空间和To空间的角色发生互换，From空间变为To空间，To空间变为From空间。

简而言之，在新生代的垃圾回收过程中，就是通过将存活对象在两个空间之间进行复制。

复制算法的缺点是只能使用新生代内存中的一半内存空间大小。但复制算法由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上有优异的表现。

当一个对象经过多次复制依然存活时，它将会被认为是生命周期较长的对象。这种较长生命周期的对象随后会被移动到老龄代内存中，采用老龄代中新的算法进行管理。

对象从新生代晋升到老龄代的条件主要有两个：一个是对象是否经历过复制算法回收，一个是To空间的内存占用比超过一定的限制。

### 标记算法

标记清除算法分为两个阶段，一阶段是标记，另一阶段是清除。
与复制算法相比，标记－清除算法并不会将内存空间划分为两半，所以不存在浪费一半空间的行为。
与复制算法不同的是，标记－清除算法在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。

可以看出复制算法只复制活着的对象，而标记－清除算法只清理死亡的对象。这是因为活对象在新生代中占较小部分，死对象在老龄代中占较小部分，这也是两种回收方式能高效工作的原因。

标记－清除算法最大的问题是在进行一次标记清除回收后，内存空间会出现不连续的状态。
这些内存碎片会对后续的内存分配造成问题，因为很可能出现需要分配一个大内存对象的情况，这时无法分配的情况下就会再次触发垃圾回收，而这次的回收是不必要的。

#### 标记-合并算法

标记－合并算法就是为了解决这些弊端而设计演变出来的。

它们的差别在于对象在标记为死亡后，在整理的过程中，将活着的对象往一端移动，在移动完成后，直接清理掉另一端死亡的对象。
完成移动并清理完另一端死亡对象的内存后，老龄代内存空间就是连续的未使用和以使用了，这样就可以进行大内存对象的分配了。